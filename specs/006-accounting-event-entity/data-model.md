# Data Model: Accounting Event Entity

**Feature**: 006-accounting-event-entity
**Date**: 2026-02-06

## New Entity: `accounting_events`

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| id | serial | PK | Auto-increment primary key |
| scenario_id | integer | FK → scenarios(id) ON DELETE CASCADE, NOT NULL | Owning scenario |
| source_message_id | integer | FK → conversation_messages(id) ON DELETE SET NULL, nullable | AI message that first created this event |
| event_name | varchar(100) | NOT NULL | Display name (e.g., "Payment Received") |
| description | text | nullable | Event description from AI or user edit |
| event_type | varchar(50) | nullable | Free-text classification (e.g., "revenue", "expense", "transfer") |
| metadata | jsonb | nullable, default {} | Extensible metadata for future use |
| is_confirmed | boolean | NOT NULL, default false | Whether user has confirmed this event |
| created_at | timestamp | NOT NULL, default NOW() | Creation timestamp |
| updated_at | timestamp | NOT NULL, default NOW() | Last update timestamp |

**Indexes**:
- `idx_accounting_events_scenario_id` on (scenario_id)
- `idx_accounting_events_source_message_id` on (source_message_id)
- `idx_accounting_events_is_confirmed` on (is_confirmed)

**Unique Constraints**:
- `unique_scenario_event_name` on (scenario_id, LOWER(event_name)) — enforces one event per name per scenario

## Modified Entity: `journal_rules`

| Field | Change | Type | Constraints |
|-------|--------|------|-------------|
| event_id | ADD | integer | FK → accounting_events(id) ON DELETE SET NULL, nullable |

**New Index**: `idx_journal_rules_event_id` on (event_id)

Existing fields `event_name`, `event_description`, and `rule_key` are **retained** for backward compatibility.

## Modified Entity: `analysis_entries`

| Field | Change | Type | Constraints |
|-------|--------|------|-------------|
| event_id | ADD | integer | FK → accounting_events(id) ON DELETE SET NULL, nullable |

**New Index**: `idx_analysis_entries_event_id` on (event_id)

Existing field `event_name` is **retained** for backward compatibility.

## Entity Relationships

```
scenarios (1) ──────< (N) accounting_events
                              │
                              ├──< (N) journal_rules      (via event_id, nullable)
                              └──< (N) analysis_entries    (via event_id, nullable)

conversation_messages (1) ──< (N) accounting_events (via source_message_id, nullable)
```

## Drizzle ORM Relations

New relations to add:

- `accountingEvents` → `scenarios` (many-to-one via scenarioId)
- `accountingEvents` → `conversationMessages` (many-to-one via sourceMessageId)
- `accountingEvents` → `journalRules` (one-to-many)
- `accountingEvents` → `analysisEntries` (one-to-many)
- `journalRules` → `accountingEvents` (many-to-one via eventId)
- `analysisEntries` → `accountingEvents` (many-to-one via eventId)

## Migration Plan

**Migration file**: Auto-generated by `drizzle-kit generate`, then manually append backfill SQL.

### Step 1: Create `accounting_events` table
Standard DDL from Drizzle schema diff.

### Step 2: Add `event_id` columns
```sql
ALTER TABLE journal_rules ADD COLUMN event_id INTEGER REFERENCES accounting_events(id) ON DELETE SET NULL;
ALTER TABLE analysis_entries ADD COLUMN event_id INTEGER REFERENCES accounting_events(id) ON DELETE SET NULL;
```

### Step 3: Backfill existing data
```sql
-- Create events from journal_rules
INSERT INTO accounting_events (scenario_id, event_name, description, is_confirmed, created_at, updated_at)
SELECT DISTINCT
  jr.scenario_id,
  jr.event_name,
  jr.event_description,
  true,
  MIN(jr.created_at),
  NOW()
FROM journal_rules jr
WHERE jr.event_name IS NOT NULL
GROUP BY jr.scenario_id, jr.event_name, jr.event_description;

-- Create events from analysis_entries not already covered
INSERT INTO accounting_events (scenario_id, event_name, is_confirmed, created_at, updated_at)
SELECT DISTINCT
  ae.scenario_id,
  ae.event_name,
  false,
  MIN(ae.created_at),
  NOW()
FROM analysis_entries ae
WHERE ae.event_name IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM accounting_events ev
    WHERE ev.scenario_id = ae.scenario_id
      AND LOWER(ev.event_name) = LOWER(ae.event_name)
  )
GROUP BY ae.scenario_id, ae.event_name;

-- Link journal_rules to events
UPDATE journal_rules jr
SET event_id = ev.id
FROM accounting_events ev
WHERE jr.scenario_id = ev.scenario_id
  AND LOWER(jr.event_name) = LOWER(ev.event_name)
  AND jr.event_name IS NOT NULL;

-- Link analysis_entries to events
UPDATE analysis_entries ae
SET event_id = ev.id
FROM accounting_events ev
WHERE ae.scenario_id = ev.scenario_id
  AND LOWER(ae.event_name) = LOWER(ev.event_name)
  AND ae.event_name IS NOT NULL;
```

### Rollback Plan
```sql
ALTER TABLE journal_rules DROP COLUMN event_id;
ALTER TABLE analysis_entries DROP COLUMN event_id;
DROP TABLE accounting_events;
```
No data loss — original `event_name` fields are untouched.

## Zod Schemas

### AccountingEvent (API response)
```typescript
const accountingEventSchema = z.object({
  id: z.number(),
  scenarioId: z.number(),
  eventName: z.string().max(100),
  description: z.string().nullable(),
  eventType: z.string().max(50).nullable(),
  isConfirmed: z.boolean(),
  ruleCount: z.number().optional(),    // computed in list queries
  entryCount: z.number().optional(),   // computed in list queries
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
})
```

### UpdateEvent (API input)
```typescript
const updateEventSchema = z.object({
  eventName: z.string().min(1).max(100).optional(),
  description: z.string().max(2000).nullable().optional(),
  eventType: z.string().max(50).nullable().optional(),
})
```

### MergeEvents (API input)
```typescript
const mergeEventsSchema = z.object({
  sourceEventId: z.number(),
  targetEventId: z.number(),
})
```
